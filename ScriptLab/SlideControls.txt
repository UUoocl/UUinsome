name: UUinsome Slide Controls
description: >-
  A script to create a WebSocket connection between Open Broadcast Studio (OBS)
  and PowerPoint M365. This script is for PowerPoint M365 Desktop app on
  Windows.  

  Documentation: https://github.com/UUoocl/UUinsome
host: POWERPOINT
api_set: {}
script:
  content: >
    // A script to control Open Broadcast Studio (OBS) with PowerPoint Slides

    // Add a Textbox to each slide and enter an OBS scene name.

    // Name the text box "obsScene"

    //

    // The OBS scene will change when the slide changes.

    //

    // NOTE: this script only works in 'window slide show mode'


    $("#get-slide-metadata").on("click", currentSlide);

    $("#previous-slide").on("click", goToPreviousSlideByIndex);

    $("#next-slide").on("click", goToNextSlideByIndex);

    $("#connect-to-OBS").on("click", connectToOBS);

    $("#add-to-all-slides").on("click", addToAllSlides);

    $("#add-to-slide").on("click", addToSelectedSlide);

    $("#make-tag-list").on("click", makeScenetags);


    async function addToSelectedSlide() {
      await PowerPoint.run(async (context) => {
        context.presentation.load("slides");
        await context.sync();
        let selectedSlideMetadata = await getSelectedSlideMetadata();
        //console.log(`current slide metadata, ${JSON.stringify(selectedSlideMetadata)}`);
        //convert JSON to javaScript object
        selectedSlideMetadata = JSON.parse(JSON.stringify(selectedSlideMetadata));
        // Decrement because the getSelectedSlideByIndex method is 1-based,
        // but the getItemAt method is 0-based.
        selectedSlideMetadata.index = selectedSlideMetadata.index - 1;

        let i = selectedSlideMetadata.index;
        makeShapes(context, i, -360, 0, 270, 350, "D5F4DD", 0, "obs-Entrance-BG", "");
        makeShapes(context, i, -335, 5, 25, 300, "9CD3D9", 0, "obs-Entrance-title", "Entrance");
        makeShapes(context, i, -355, 35, 25, 340, "9CD3D9", 0, "obs-Entrance-Scene", "scene");
        makeShapes(context, i, -355, 65, 25, 340, "9CD3D9", 0, "obs-Entrance-camera", "camera");
        makeShapes(context, i, -355, 95, 25, 340, "9CD3D9", 0, "obs-Entrance", "");
        makeShapes(context, i, -355, 125, 25, 340, "9CD3D9", 0, "obs-Entrance", "");
        makeShapes(context, i, -355, 155, 25, 340, "9CD3D9", 0, "obs-Entrance", "");
        makeShapes(context, i, -360, 270, 270, 350, "EFB8B6", 0, "obs-Exit-BG", "");
        makeShapes(context, i, -335, 275, 25, 300, "FFA99B", 0, "obs-Exit-title", "Exit");
        makeShapes(context, i, -355, 305, 25, 340, "FFA99B", 0.01, "obs-Exit-Scene", "scene");
        makeShapes(context, i, -355, 335, 25, 340, "FFA99B", 0.01, "obs-Exit-camera", "camera");
        makeShapes(context, i, -355, 365, 25, 340, "FFA99B", 0.01, "obs-Exit", "");
        makeShapes(context, i, -355, 395, 25, 340, "FFA99B", 0.01, "obs-Exit", "");
        makeShapes(context, i, -355, 425, 25, 340, "FFA99B", 0.01, "obs-Exit", "");
        makeShapes(context, i, 0, -275, 270, 700, "FFFFFF", 0.0, "obs-Notes", "Enter Notes");
      });
    }


    async function addToAllSlides() {
      // add UUinsome tags to each slide
      await PowerPoint.run(async (context) => {
        context.presentation.load("slides");

        await context.sync();
        const allSlidesCount = context.presentation.slides.getCount();
        // context.presentation.slides.load("items");
        await context.sync();
        for (let i = 0; i < allSlidesCount.value; i++) {
          makeShapes(context, i, -360, 0, 270, 350, "D5F4DD", 0, "obs-Entrance-BG", "");
          makeShapes(context, i, -335, 5, 25, 300, "9CD3D9", 0, "obs-Entrance-title", "Entrance");
          makeShapes(context, i, -355, 35, 25, 340, "9CD3D9", 0, "obs-Entrance-Scene", "scene");
          makeShapes(context, i, -355, 65, 25, 340, "9CD3D9", 0, "obs-Entrance-camera", "camera");
          makeShapes(context, i, -355, 95, 25, 340, "9CD3D9", 0, "obs-Entrance", "");
          makeShapes(context, i, -355, 125, 25, 340, "9CD3D9", 0, "obs-Entrance", "");
          makeShapes(context, i, -355, 155, 25, 340, "9CD3D9", 0, "obs-Entrance", "");
          makeShapes(context, i, -360, 270, 270, 350, "EFB8B6", 0, "obs-Exit-BG", "");
          makeShapes(context, i, -335, 275, 25, 300, "FFA99B", 0, "obs-Exit-title", "Exit");
          makeShapes(context, i, -355, 305, 25, 340, "FFA99B", 0.01, "obs-Exit-Scene", "scene");
          makeShapes(context, i, -355, 335, 25, 340, "FFA99B", 0.01, "obs-Exit-camera", "camera");
          makeShapes(context, i, -355, 365, 25, 340, "FFA99B", 0.01, "obs-Exit", "");
          makeShapes(context, i, -355, 395, 25, 340, "FFA99B", 0.01, "obs-Exit", "");
          makeShapes(context, i, -355, 425, 25, 340, "FFA99B", 0.01, "obs-Exit", "");
          makeShapes(context, i, 0, -275, 270, 700, "FFFFFF", 0.0, "obs-Notes", "Enter Notes");
        }
        // let allSlideItems: PowerPoint.Slide[] = context.presentation.slides.items;
        // allSlideItems.map((slide, index) => {
        //   allSlidesList[slide.id] = `Slide ${index + 1}`;
        // });
      });
    }


    async function makeShapes(context, i, left, top, height, width, color,
    transparency, name, text) {
      const shapes: PowerPoint.ShapeCollection = context.presentation.slides.getItemAt(i).shapes;
      const shapeOptions: PowerPoint.ShapeAddOptions = {
        left: left,
        top: top,
        height: height,
        width: width
      };
      const newShape: PowerPoint.Shape = shapes.addGeometricShape(
        PowerPoint.GeometricShapeType.roundRectangle,
        shapeOptions
      );
      newShape.name = name;
      newShape.fill.foregroundColor = color;
      newShape.fill.transparency = transparency;
      newShape.textFrame.textRange.font.color = "black";
      newShape.textFrame.textRange.font.size = 16;
      newShape.textFrame.textRange.text = text;
      if (name === "obs-Notes") {
        newShape.textFrame.verticalAlignment = "Bottom";
        newShape.textFrame.autoSizeSetting = "AutoSizeShapeToFitText";
      }
    }


    function getSelectedSlideMetadata() {
      // Wrap a call of one of the Common APIs in a Promise-returning
      // function, so that it can be easily called within a run() function
      // of an application-specific API.
      return new OfficeExtension.Promise<any>(function(resolve, reject) {
        Office.context.document.getSelectedDataAsync(Office.CoercionType.SlideRange, function(asyncResult) {
          try {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
              reject(console.error(asyncResult.error.message));
            } else {
              const result = asyncResult.value as any;
              resolve(result.slides[0]);
            }
          } catch (error) {
            reject(console.log(error));
          }
        });
      });
    }


    //Button triggers

    async function currentSlide() {
      //Get Current Slide Title and Index
      let selectedSlideMetadata = await getSelectedSlideMetadata();
      //console.log(`current slide metadata, ${JSON.stringify(selectedSlideMetadata)}`);

      //convert JSON to javaScript object
      selectedSlideMetadata = JSON.parse(JSON.stringify(selectedSlideMetadata));
      // Decrement because the getSelectedSlideByIndex method is 1-based,
      // but the getItemAt method is 0-based.
      selectedSlideMetadata.index = selectedSlideMetadata.index - 1;
      //console.log(`current slide metadata, ${JSON.stringify(selectedSlideMetadata)}`);

      //get current slide entrance data
      let pptData = await getNotesForOBS(selectedSlideMetadata.index, "entrance");
      pptData["slideTitle"] = selectedSlideMetadata.title;
      //console.log(`pptData returned ${JSON.stringify(pptData)}`);

      await sendWebsocketMessageToOBS(pptData);
    }


    async function goToNextSlideByIndex() {
      //getSlideMetadata("next");

      await PowerPoint.run(async function(context) {
        //Get Current Slide Title and Index
        let selectedSlideMetadata = await getSelectedSlideMetadata();
        //console.log(`current slide metadata, ${JSON.stringify(selectedSlideMetadata)}`);

        //convert JSON to javaScript object
        selectedSlideMetadata = JSON.parse(JSON.stringify(selectedSlideMetadata));
        // Decrement because the getSelectedSlideByIndex method is 1-based,
        // but the getItemAt method is 0-based.
        selectedSlideMetadata.index = selectedSlideMetadata.index - 1;
        //console.log(`current slide metadata, ${JSON.stringify(selectedSlideMetadata)}`);

        //get current slide exit data
        let pptData = await getNotesForOBS(selectedSlideMetadata.index, "exit");
        pptData["slideTitle"] = selectedSlideMetadata.title;
        //console.log(`pptData returned ${JSON.stringify(pptData)}`);

        //send slide data to OBS
        if (platform != "Mac") {
          await sendWebsocketMessageToOBS(pptData);
        }

        //get the next slide
        await goToNextSlide();

        //get current slide entrance data
        pptData = await getNotesForOBS(selectedSlideMetadata.index + 1, "entrance");
        //console.log(`pptData Entrance returned ${JSON.stringify(pptData)}`);

        //send slide data to OBS
        if (platformType != "Mac") {
          await sendWebsocketMessageToOBS(pptData);
        }
      });
    }


    async function goToPreviousSlideByIndex() {
      //getSlideMetadata("previous");

      await PowerPoint.run(async function(context) {
        //Get Current Slide Title and Index
        let selectedSlideMetadata = await getSelectedSlideMetadata();
        //console.log(`current slide metadata, ${JSON.stringify(selectedSlideMetadata)}`);

        //convert JSON to javaScript object
        selectedSlideMetadata = JSON.parse(JSON.stringify(selectedSlideMetadata));
        // Decrement because the getSelectedSlideByIndex method is 1-based,
        // but the getItemAt method is 0-based.
        selectedSlideMetadata.index = selectedSlideMetadata.index - 1;
        //console.log(`current slide metadata, ${JSON.stringify(selectedSlideMetadata)}`);

        //get current slide exit data
        let pptData = await getNotesForOBS(selectedSlideMetadata.index, "exit");
        pptData["slideTitle"] = selectedSlideMetadata.title;
        //console.log(`pptData returned ${JSON.stringify(pptData)}`);

        await sendWebsocketMessageToOBS(pptData);

        //get the next slide
        await goToPreviousSlide();

        //get current slide entrance data
        pptData = await getNotesForOBS(selectedSlideMetadata.index - 1, "entrance");
        //console.log(`pptData Entrance returned ${JSON.stringify(pptData)}`);

        //send slide data to OBS
        await sendWebsocketMessageToOBS(pptData);
      });
    }


    //change slide

    async function goToNextSlide() {
      return new OfficeExtension.Promise<any>(function(resolve, reject) {
        const goToNext = Office.Index.Next;
        Office.context.document.goToByIdAsync(goToNext, Office.GoToType.Index, function(asyncResult) {
          try {
            if (asyncResult.status == "failed") {
              console.log("Action failed with error: " + asyncResult.error.message);
            } else {
              //console.log(`Navigation successful`);
              resolve();
            }
          } catch (error) {
            reject(console.log(error));
          }
        });
      });
    }


    async function goToPreviousSlide() {
      return new OfficeExtension.Promise<any>(function(resolve, reject) {
        const goToPrevious = Office.Index.Previous;
        Office.context.document.goToByIdAsync(goToPrevious, Office.GoToType.Index, function(asyncResult) {
          try {
            if (asyncResult.status == "failed") {
              console.log("Action failed with error: " + asyncResult.error.message);
            } else {
              //console.log(`Navigation successful`);
              resolve();
            }
          } catch (error) {
            reject(console.log(error));
          }
        });
      });
    }


    // get the shapes where the name begins with "obs-" on the current slide.

    async function getNotesForOBS(slideIndex, action) {
      var pptData = { actionName: `slide_${action}` },
        found = 0;
      const indexArray = [];
      const shapeNames = [];
      let result = await PowerPoint.run(async (context) => {
        // Get every shape in the current slide.
        const shapes: PowerPoint.ShapeCollection = context.presentation.slides.getItemAt(slideIndex).shapes;
        //load all the shape properties
        shapes.load("items");

        await context.sync();

        await shapes.items.forEach(async (shape, index) => {
          // find the "|||" shapes index
          if (shape.name.startsWith("obs-")) {
            found = 1;
            indexArray.push(index);
            shapeNames.push(shape.name);
            //    console.log(`index: ${index}, ID: ${shape.id}, Name: ${shape.name}`);
          }
        });
        //get Shape Text
        const shapeTextRanges = [];
        const shapeFills = [];
        if (found) {
          //load text console.log(indexArray.length);
          for (let i = 0; i < indexArray.length; i++) {
            const shapeTextRange: PowerPoint.TextRange = shapes.getItemAt(indexArray[i]).textFrame.textRange;
            const shapeFill: PowerPoint.ShapeFill = shapes.getItemAt(indexArray[i]).fill;
            shapeTextRanges.push(shapeTextRange);
            shapeTextRanges[i].load("text");
            shapeFills.push(shapeFill);
            shapeFills[i].load("transparency");
          }
          //console.log(shapeTextRanges, shapeFills);
        }
        await context.sync();

        //Action to Transparency value
        let actionCode;
        switch (action) {
          case "entrance" || "current":
            actionCode = '\\\\\\';
            break; //Entrance
          case "exit":
            actionCode = "///";
            break; //Exit
        }
        //console.log(`action ${action} actionscode ${actionCode}`);
        //build the message
        for (let i = 0; i < shapeTextRanges.length; i++) {
          if (shapeTextRanges[i].text.includes(actionCode)){
            const keyValue = shapeTextRanges[i].text.split(actionCode);
            //console.log(`tag: ${shapeTextRanges[i].text} ActionCode: ${actionCode} transparecy ${shapeFills[i].transparency === actionCode}`)
            pptData[keyValue[0].trim()] = keyValue[1].trim();
          }
          if (shapeNames[i] === "obs-Notes" && (action === "entrance" || action === "current")) {
            pptData["notes"] = JSON.stringify(shapeTextRanges[i].text);
          }
        }
        pptData.slidePosition = slideIndex;
        //console.log("pptData in function", pptData);

        //await sendWebsocketMessageToOBS(pptData);
      });
      return pptData;
    }


    var obs = new OBSWebSocket();

    async function connectToOBS() {
      //connect to OBS Websocket localhost
      //Get websocket connection info
      //Enter the websocketIP address
      const websocketIP = document.getElementById("IP").value;

      //Enter the OBS websocket port number
      const websocketPort = document.getElementById("Port").value;

      //Enter the OBS websocket server password
      const websocketPassword = document.getElementById("PW").value;

      //console.log(`ws://${websocketIP}:${websocketPort}`);
      // connect to OBS websocket
      try {
        const { obsWebSocketVersion, negotiatedRpcVersion } = await obs.connect(
          `ws://${websocketIP}:${websocketPort}`,
          websocketPassword,
          {
            rpcVersion: 1
          }
        );
        //console.log(`Connected to server ${obsWebSocketVersion} (using RPC ${negotiatedRpcVersion})`);
        document.getElementById("connectToOBS").style.display = "none";
        document.getElementById("tagList").style.display = "block";
        getSceneList();
      } catch (error) {
        console.error("Failed to connect", error.code, error.message);
      }
      obs.on("error", (err) => {
        console.error("Socket error:", err);
      });
    }


    async function getSceneList() {
      const sceneList = await obs.call("GetSceneList");
      sceneList.scenes.forEach((scene, index) => {
        // find scenes starting with "Scene"
        if (scene.sceneName.startsWith("scene|||")) {
          document.getElementById("sceneList").innerHTML =
            document.getElementById("sceneList").innerHTML + `<li class="ms-Button">${scene.sceneName}</li>`;
        }
        if (scene.sceneName === "Camera") {
          getCameraList();
        }
      });
      addListItemClickListener();
    }


    async function getCameraList() {
      let cameraSources = await obs.call("GetSceneItemList", { sceneName: "Camera" });
      cameraSources.sceneItems.forEach((source, index) => {
        document.getElementById("cameraList").innerHTML =
          document.getElementById("cameraList").innerHTML + `<li class="ms-Button">camera||| ${source.sourceName}</li>`;
      });
      addListItemClickListener();
    }


    async function addListItemClickListener() {
      //add a click listener to each list item
      const listItems = document.querySelectorAll("li");
      listItems.forEach((item) => {
        item.addEventListener("click", async function(event) {
          await PowerPoint.run(async (context) => {
            const shapes: PowerPoint.ShapeScopedCollection = context.presentation.getSelectedShapes();
            await context.sync();
            shapes.load("items");
            await context.sync();
            shapes.items[0].load()
            const shapeFill: PowerPoint.ShapeFill = shapes.items[0].fill;
            shapeFill.load("transparency");
            await context.sync();
            const tagType = shapeFill.transparency === 0 ? '\\\\\\':"///"
            shapes.items[0].textFrame.textRange.text = event.target.textContent.replace('|||', tagType);
          });
        });
      });
    }


    obs.on("InputSettingsChanged", async function(event) {
      //console.log(`OBS source setting changed, ${event}`);
      //if ppt scriptlab text source
      if (event.inputName === "Navigation Text") {
        //get the message
        const navigate = event.inputSettings.text;
        //if next
        if (navigate === "Next") {
          goToNextSlideByIndex();
          setTimeout(clearNavigateRequest, 3000);
        }
        //if current
        if (navigate === "Current") {
          goToNextSlideByIndex();
          setTimeout(clearNavigateRequest, 3000);
        }
        //if previous
        if (navigate === "Previous") {
          goToPreviousSlideByIndex();
          setTimeout(clearNavigateRequest, 3000);
        }
      }
    });


    //clear text source

    async function clearNavigateRequest() {
      await obs.call("SetInputSettings", {
        inputName: "Navigation Text",
        inputSettings: {
          text: ""
        }
      });
    }


    //return Slide details to OBS

    async function sendWebsocketMessageToOBS(pptSlideDetails) {
      //send slide details to OBS Browser
      //console.log(`slide websocket message| ${JSON.stringify(pptSlideDetails)}`);
      await obs.call("CallVendorRequest", {
        vendorName: "obs-browser",
        requestType: "emit_event",
        requestData: {
          event_name: "powerpoint-message",
          event_data: { pptSlideDetails }
        }
      });

      //send slide details to Advanced Scene Switcher
      await obs.call("CallVendorRequest", {
        vendorName: "AdvancedSceneSwitcher",
        requestType: "AdvancedSceneSwitcherMessage",
        requestData: {
          message: `${JSON.stringify(pptSlideDetails)}`
        }
      });

      return;
    }


    var platform;

    function getPlatform() {
      const contextInfo = Office.context.diagnostics;
      const platformType: Office.PlatformType = contextInfo.platform;
      console.log("Platform: " + platformType);
      platform = platformType;
      if (platformType === "Mac") {
        document.getElementById("connectToOBS").style.display = "none";
      }
    }


    getPlatform();


    function makeScenetags() {
      document.getElementById("pasteOBSscenes").style.display = "none";
      document.getElementById("tagList").style.display = "block";
      let sceneInput = document.getElementById("obsScenes").value;
      sceneInput = JSON.parse(sceneInput);
      //console.log(sceneInput, typeof sceneInput);
      sceneInput.scenes.forEach((scene, index) => {
        // find scenes starting with "Scene"
        if (scene.sceneName.startsWith("scene|||")) {
          document.getElementById("sceneList").innerHTML =
            document.getElementById("sceneList").innerHTML + `<li class="ms-Button">${scene.sceneName}</li>`;
        }
        if (scene.sceneName === "Camera") {
          scene.sources.forEach((source, index) => {
            document.getElementById("cameraList").innerHTML =
              document.getElementById("cameraList").innerHTML + `<li class="ms-Button">camera||| ${source}</li>`;
          });
        }
      });
      addListItemClickListener();
    }


    //general Office.initialize function. Fires on load of the add-in.

    Office.initialize = function() {
      //var Globals = { activeViewHandler: 0, firstSlideId: 0 };

      //console.log(getActiveFileView())
      //Gets whether the current view is edit or read.
      const currentView = getActiveFileView();

      //register for the active view changed handler
      registerActiveViewChanged();

      //render the content based off of the currentView
      //....
    };


    function getActiveFileView() {
      Office.context.document.getActiveViewAsync(function(asyncResult) {
        if (asyncResult.status == "failed") {
          console.log("Action failed with error: " + asyncResult.error.message);
        } else {
          console.log(asyncResult.value);
        }
      });
    }


    function registerActiveViewChanged() {
      Globals.activeViewHandler = function(args) {
        console.log(JSON.stringify(args));
      };

      Office.context.document.addHandlerAsync(Office.EventType.ActiveViewChanged, Globals.activeViewHandler, function(
        asyncResult
      ) {
        if (asyncResult.status == "failed") {
          console.log("Action failed with error: " + asyncResult.error.message);
        } else {
          console.log(asyncResult.status);
        }
      });
    }
  language: typescript
template:
  content: "<section class=\"ms-font-m\">\n\t<p class=\"ms-font-m\">Add UUinsome controls</p>\n\n\t<button id=\"add-to-slide\" class=\"ms-Button\">\n\t\t\t<span class=\"ms-Button-label\">Add to selected slide</span>\n\t</button>\n\n\t<button id=\"add-to-all-slides\" class=\"ms-Button\">\n\t\t\t<span class=\"ms-Button-label\">Add to all alides</span>\n\t</button>\n\n</section>\n<section class=\"ms-font-m\">\n\t<p class=\"ms-font-m\">Navigate the presentation.</p>\n</section>\n\n<button id=\"get-slide-metadata\" class=\"ms-Button\">\n    <span class=\"ms-Button-label\">Get current slide notes</span>\n</button>\n\n<button id=\"next-slide\" class=\"ms-Button\">\n    <span class=\"ms-Button-label\">Next slide</span>\n</button>\n\n<button id=\"previous-slide\" class=\"ms-Button\">\n    <span class=\"ms-Button-label\">Previous slide</span>\n</button>\n\n\n<section id=\"connectToOBS\" class=\"setup ms-font-m\">\n\t<h3>OBS WebSocket Server Settings</h3>\n\t<p class=\"ms-font-m\">Connect PowerPoint to OBS</p>\n\t<span class=\"ms-Button-label\">Enter WebSocket Server IP Address</span>\n\t<Input id=\"IP\" class=\"ms-Button\" value=\"localhost\"></Input>\n\t<span class=\"ms-Button-label\">Enter WebSocket Server Port</span><br>\n\t<Input id=\"Port\" class=\"ms-Button\" value=\"4455\"></Input>\n\t<span class=\"ms-Button-label\">Enter WebSocket Server Password</span><br>\n\t<Input type=\"password\" id=\"PW\" class=\"ms-Button\"></Input>\n\t<button id=\"connect-to-OBS\" class=\"ms-Button\">\n\t      <span class=\"ms-Button-label\">Connect to OBS WebSocket Server</span>\n    </button>\n</section>\n\n<section id=\"pasteOBSscenes\" class=\"setup ms-font-m\">\n\t<h3>Manually enter OBS scenes</h3>\n\t<p class=\"ms-font-m\">Use the Get User Media,<b> https://uuoocl.github.io/GUM/</b>, Github page to create a list of\n\t\tyour OBS Scenes and Sources. Copy and paste the list</p>\n\t<span class=\"ms-Button-label\">Enter Scenes and Sources</span>\n\t<Input id=\"obsScenes\" class=\"ms-Button\"></Input>\n\t<button id=\"make-tag-list\" class=\"ms-Button\">\n\t  <span class=\"ms-Button-label\">Make a list tags</span>\n  </button>\n</section>\n\n\n<section id=\"tagList\" class=\"setup ms-font-m\" hidden>\n\t<h3>Scenes</h3>\n\t<span class=\"ms-Button-label\">Select a Shape, then click a value below to set the Shape's text</span>\n\n\t<ul id=sceneList>\n\t</ul>\n\n\t<h3>Camera</h3>\n\t<ul id=cameraList>\n\t</ul>\n\t<p>Shapes that indicate an Entrance tag include the text \"\\\\\\\" and have 0% Transparency.<br>\n\tShapes that indicate an Entrance tag include the text \"///\" and have 1% Transparency.</p>\n\n</section>"
  language: html
style:
  content: |
    section.samples {
        margin-top: 20px;
    }

    section.samples .ms-Button, section.setup .ms-Button {
      display: block;
      margin-bottom: 5px;
      margin-left: 0px;
      min-width: 80px;
    }

    ul, .ms-Button{
      padding: 0;
      list-style-type: none;
      margin: 0;
      margin-bottom: 2px;
      margin-left: 0px;
    }

    p {
       font-size: smaller;
       line-height: normal;
    }
  language: css
libraries: |-
  https://appsforoffice.microsoft.com/lib/1/hosted/office.js
  @types/office-js

  office-ui-fabric-js@1.4.0/dist/css/fabric.min.css
  office-ui-fabric-js@1.4.0/dist/css/fabric.components.min.css

  core-js@2.4.1/client/core.min.js
  @types/core-js

  jquery@3.1.1
  @types/jquery@3.3.1
  obs-websocket-js
